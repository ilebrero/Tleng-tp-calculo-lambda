\documentclass{article}

\usepackage[utf8]{inputenc}

\usepackage{caratula}

\usepackage{graphicx}
\usepackage{enumerate}

\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{amsthm}

\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listingsutf8}

\usepackage{float}
\floatplacement{figure}{h!}

\usepackage{geometry}
\usepackage{wrapfig}
\usepackage{cite}
\usepackage{dsfont}
\usepackage{xcolor}

\usepackage[space]{grffile}
 
\usepackage{booktabs}

\usepackage{verbatim}
\usepackage{qtree}

\newtheorem{theorem}{Teorema}[section]
\newtheorem{corollary}{Corolario}[theorem]
\newtheorem{lemma}{Lema}[theorem]
 
\theoremstyle{definition}
\newtheorem{definition}{Definición}[section]
 
\theoremstyle{remark}
\newtheorem*{remark}{Observación}
 
\lstset{
	basicstyle=\itshape,
	xleftmargin=3em,
	literate={->}{$\rightarrow$}{2}
} 
 
\begin{document}
% Estos comandos deben ir antes del \maketitle
\materia{Teoria de Lenguajes} % obligatorio

\titulo{TP1}
\subtitulo{Analizador Sintáctico y Semántico para $\lambda^{bn}$ \\ \today}
\grupo{Grupo: }
 
\integrante{Francisco Leto}{249/09}{leto.francisco@gmail.com}
\integrante{Ignacio Lebrero Rial}{}{}
\integrante{Federico Beuter}{827/13}{federicobeuter@gmail.com}
 
\maketitle

\tableofcontents

\pagebreak

\section{Introduccion}

En este infome se describe la implementacion de un analizador sintactico y semantico para $\lambda^{bn}$. En base al lenguaje presentado se procedio a construir una gramatica acorde, la cual luego fue utilizada para implementar el correspondiente Lexer y Parser. La implementacion fue realizado empleando Python junto con la libreria PLY (\textbf{P}ython \textbf{L}ex-\textbf{Y}acc) \footnote{PLY (Python Lex-Yacc): http://www.dabeaz.com/ply/ply.html}.

\section{Gramatica}

\subsection{Lexer}

El primer paso para la construcción de nuestra gramática fue la identificación de los \emph{tokens} y palabras reservadas. Utilizamos las siguientes palabras reservadas y literales: \textbf{if, then, else, succ, pred, iszero, true, false, `(', `)', `.', `\textbackslash', 0}. Definimos, ademas, los siguientes tokens, que se identificaron con las expresiones regulares detalladas a continuación.

\begin{center}
	\begin{tabular}{@{}ll@{}}
		\toprule
		Token & Expresion Regular \\ \midrule
		VAR\_DECLARATION &  {[}a-z\textbar A-Z{]+}:((Nat\textbar Bool)-\textgreater (Nat\textbar Bool)\textbar Nat\textbar Bool)\\
		VAR\_USAGE &  {[}a-z\textbar A-Z{]+}\\
		\bottomrule
	\end{tabular}
\end{center}

Ademas, el lexer ignora los caracteres en blanco y descompone el token de VAR\_DECLARATION en un objeto con el valor de la variable y su tipo. En la implementación, los literales se definieron como tokens para facilitar la implementación.

La gramática propuesta intenta ser lo mas simple posible, teniendo en cuenta la precedencia y asociatividad de los operadores, y evitando ambigüedades.


\begin{lstlisting}
E -> (E) | A
A -> \ VAR_DECLARATION.E | C
C -> if E then E else E | P
P -> E Q | F
Q -> E
F -> succ(E) | pred(E) | iszero(E) | G
G -> 0 | true | false | V
V -> VAR_USAGE
\end{lstlisting}


\section{Analisis Semantico}

Nuestro codigo, utilizando \emph{PLY} construye un parser LARL para la gramática propuesta. Luego le agregamos semantica, que permite realizar el chequeo e inferencia de tipo, junto con la evaluación de las cadenas bien formadas. Parte de lo implementado consiste en: 

\begin{itemize}
	\item Asegurar que la guarda de la condición sea del tipo booleano.
	\item Asegurar que ambas ramas de la condición tengan el mismo tipo.
	\item Se asegura de que el tipo de la variable en la abstracción lambda sea valido.
	\item Se asegura de que \texttt{succ} y \texttt{pred} y \texttt{iszero} se apliquen solamente a valores de tipo \texttt{Nat}.
	\item Infiere los tipos cuando esto es posible.
	\item Respeta la precedencia y asociatividad al evaluar la cadenas de entrada.
\end{itemize}

\section{Evaluaciones}

\subsection{Expresiones correctas}

\begin{tabular}{|l|l|}
\hline
Expresion                                                                    & Evaluacion                                          \\ \hline
if true then (\textbackslash x:Bool.false) else (\textbackslash x:Bool.true) & \textbackslash x:Bool.false:Bool-\textgreater Bool   \\ \hline
\textbackslash x:Nat.iszero(x)                                               & \textbackslash x:Nat.iszero(x):Nat-\textgreater Bool \\ \hline
pred(succ(succ(0)))                                                          & succ(0):Nat                                         \\ \hline
\end{tabular}

\subsection{Expresiones incorrectas}

\begin{tabular}{|l|l|}
\hline
Expresion                                            & Salida                                                   \\ \hline
if true then false else (\textbackslash x:Bool.true) & ERROR: Las dos opciones del if deben tener el mismo tipo \\ \hline
\textbackslash x.Not.succ(x)                         & Hubo un error en el parseo. Sintaxis invalida            \\ \hline
succ(iszero(true))                                   & ERROR: iszero espera un valor de tipo Nat                \\ \hline
\end{tabular}

\section{Manual de Usuario}

Para poder ejecutar el parser, es necesario emplear Python 3 con PLY instalado. Es posible instalar las dependencias ejecutando \textbf{pip install -r requirements.txt }Una vez que se tienen todas las dependencias, se puede ejecutar con cualquiera de los siguientes dos comandos:

\begin{itemize}
	\item \texttt{python CLambda.py}
	\item \texttt{python CLambda.py expresionLambda}
\end{itemize}

El segundo recibe la expresión lambda directamente y la evalua, mientras que el primero recibe la expresion por \texttt{stdin} mediante la consola. Los resultados de la evaluación se imprimen por \texttt{stdout} en caso de que sea satisfactoria, en el caso contrario se imprime el motivo de error por \texttt{stderr} y se para la ejecución con código de salida $1$.

En caso de utilizar la primera opción, es importante tener en cuenta el correcto escapado de los caracteres en la terminal. Para evitar estos problemas, se recomienda la segunda opción.

Ademas, se brinda el archivo \emph{tests.py} que utilizando la libreria de \emph{Python} de \emph{Unit Test} valida $13$ casos de prueba distintos, que figuran en el enunciado y sirven como validación extra respecto a los ejemplos brindados previamente. 

\section{Código fuente}

\subsection{CLambda.py}
\begin{small}
  \verbatiminput{../CLambda.py}
\end{small}

\subsection{parser\_processing.py}
\begin{small}
  \verbatiminput{../parser_processing.py}
\end{small}

\subsection{lambda\_lexer.py}
\begin{small}
  \verbatiminput{../lambda_lexer.py}
\end{small}

\subsection{lambda\_parser.py}
\begin{small}
  \verbatiminput{../lambda_parser.py}
\end{small}

\subsection{expressions.py}
\begin{small}
  \verbatiminput{../expressions.py}
\end{small}

\end{document}